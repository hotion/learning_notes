## 架构设计

![mysql逻辑架构](../../.image/mysql_jg.png)

### 如何保证crash_safe
```bash
innodb_flush_log_at_trx_commit=1 #每次redo log刷新到磁盘
sync_binlog=1 #每次binlog到磁盘
```

### 为什么不要使用长事务
innodb的隔离级别"读提交","可重复读"使用快照读,基于MVCC控制读取到的数据,如果一个事务过长,这个记录上所做的修改都保存在回滚段里面,占用存储空间和锁资源
```bash
select now(),trx_started,(UNIX_TIMESTAMP(now()) - UNIX_TIMESTAMP(trx_started)) from information_schema.innodb_trx; #查看长事务

```

### 为什么删除一半数据,空间还没减少?
```sql
innodb_file_per_table=ON
#因为innodb删除数据,只是标记删除,空间等插入数据时候可复用,数据的索引也还在,只有重建才可以
alter table T engine=InnoDB #重建表
```
### mysqldump备份数据库
```bash
#一般备份数据库需要加全局读锁
mysqldump使用参数-single-transaction相当于启动一个事务,数据库可以正常读写

```

### mysql 为什么有时候会"抖"一下
如果一个查询请求,需要刷脏页,那么mysql就需要将数据merge到磁盘,如果脏页太多,查询过程就会停顿
```bash
innodb_io_capacity=20000 #刷脏页的io速度,一般设置为磁盘iops,可以使用fio工具测
innodb_flush_neighbors=0 #是否刷邻居脏页 0不需要 1需要 一般ssd不需要
```
### count(*) count(1) Count(id) count(字段)
count(id) :遍历整张表,把每一行的id取出来,返回,server判断不为空,加1
count(1) :遍历整张表,不取值,server对于每一行,加1
count(字段):遍历整张表,返回对应的字段,如果不为null,加1
count(\*) :遍历整张表,不取值,直接加1,mysql优化器做的优化
按照效率:count(字段)<Count(id)<count(1)<count(\*),建议count(\*)

### redo log一般设置多大?
设置4个文件,每个1G

### order by
```bash
sort_buffer_size=2097152 #排序可使用的内存
max_length_for_sort_data=1024 #每一行的数据长度
```
排序过程:
1. 初始化`sort_buffer`,确定排序字段,如果选取的字段小于`max_length_for_sort_data`的长度,就取出所有字段进行全字段排序,否则进行rowid排序
2. 根据条件,选择满足条件的行的字段,放入`sort_buffer`
3. 重复步骤2
4. 对`sort_buffer`中数据按照排序字段进行排序,如果数据大于`sort_buffer_size`,需要使用外部排序,归并排序

```sql
#排序语句
select city,name,age from t where city='杭州' order by name limit 1000  ;
#增加联合索引,不需要排序步骤,因为数据已经有序
alter table t add index city_user(city, name);
#增加所有字段的联合索引,不需要回表,使用覆盖索引
alter table t add index city_user_age(city, name, age);

```