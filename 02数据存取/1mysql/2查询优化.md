## 查询优化

[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

### 索引

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引

### myisam和innodb

myisam索引的叶子节点存储的是数据地址,innodb索引的叶子节点存储的是数据,所以innodb的每个表,必须有主键,根据主键建立包含数据的叶子节点,其他索引的数据节点包含主键的索引,然后根据主键查找数据,所以不建议
主键索引过长,其他索引都要引用主索引

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页,使用非自增索引将会破坏原来的结构

### Explain

[参考](https://segmentfault.com/a/1190000008131735)

```go
//输出格式
mysql> explain select * from user_info where id = 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user_info
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 8
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

各列的含义如下:

id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.

select_type: SELECT 查询的类型.

table: 查询的是哪个表

partitions: 匹配的分区

type: join 类型

possible_keys: 此次查询中可能选用的索引

key: 此次查询中确切使用到的索引.

ref: 哪个字段或常数与 key 一起被使用

rows: 显示此查询一共扫描了多少行. 这个是一个估计值.

filtered: 表示此查询条件所过滤的数据的百分比

extra: 额外的信息
```

##### select_type

- SIMPLE, 表示此查询不包含 UNION 查询或子查询
- PRIMARY, 表示此查询是最外层的查询
- UNION, 表示此查询是 UNION 的第二或随后的查询
- DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询
- UNION RESULT, UNION 的结果
- SUBQUERY, 子查询中的第一个 SELECT
- DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.

##### type

性能关系: ALL < index < range ~ index_merge < ref < eq_ref < const < system

- system : 表中只有一条数据. 这个类型是特殊的 const 类型
- const :   针对主键或唯一索引的等值查询扫描
- eq_ref :  join 查询 前表"="后表
- ref:  join 查询, 针对于非唯一或非主键索引
- range: 表示使用索引范围查询 > < between
- index: 全索引扫描
- ALL: 全表扫描 最差

##### possible_keys
可能使用的索引，真正使用的是ｋｅｙ里面的

##### key_len
使用索引的字节数,评估组合索引是否完全使用

##### rows
查询的行数

##### Extra
当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大


### 常见优化

1. 如果明确知道只有一条结果返回，limit 1能够提高效率,明确告诉数据库，让它主动停止游标移动
2. 避免全表扫描
3. 只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量


### 全表扫描原因

1. 强制类型转换
2. 负向查询(！= 或 <>时)
3. 左模糊查询
4. is null查询
5. or条件2边一个有索引,一个没有
6. 函数操作

